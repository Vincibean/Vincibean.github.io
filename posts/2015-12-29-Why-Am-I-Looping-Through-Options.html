<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>My Hakyll Blog - Why Am I Looping Through Options??</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Why Am I Looping Through Options??</h1>

            <div class="info">
    Posted on December 29, 2015
    
</div>

<p>For those like me who started with imperative programming, functional programming may seem like a minefield, especially when familiar concepts gain different meanings. Recently, I had the opportunity to learn a couple of things about Scala, and I fell in love with Options: they deal with the infamous <a href="https://en.wikipedia.org/wiki/Tony_Hoare/Apologies_and_retractions">billion-dollar mistake</a> (whose presence simply isn’t justified in modern pointer-free languages); more importantly, by explicitly stating that a value may or may not be present, force developers to think about and deal with this possibility. In this way, Options are so different by those lurking nulls: there simply is no way you might accidentally rely on the presence of a value that is actually optional. This is well explained <a href="http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html">here</a>.</p>
<p>Yet, a familiar concept that gain a different meaning in Scala is the for loop, whenever it is associated with an Option, like in the following example:</p>
<pre><code>  for {
     language &lt;- Some(&quot;Scala&quot;)
     behavior &lt;- Some(&quot;rocks&quot;)
  } yield s&quot;$language $behavior&quot;</code></pre>
<p>Which will yield:</p>
<pre><code>  res0: Option[String] = Some(Scala rocks)</code></pre>
<p>While you may already be familiar with this, it quite puzzled me: what is the logical assumption behind this? Why should I be allowed to loop through an optional value?<br />
I had the opportunity to talk with <a href="https://github.com/stefanobaghino">Stefano Baghino</a> about this. Stefano is always ready to answer my questions, and for this I wholeheartedly thank him. Stefano explained to me that there are two possible explanations behind this: a simpler yet incorrect one, and a more involved yet more rigorous one.<br />
The first, simpler explanation (which is better exposed <a href="http://danielwestheide.com/blog/2012/12/19/the-neophytes-guide-to-scala-part-5-the-option-type.html">here</a>) simply considers an Option as a collection: a particular type of collection that contains either zero or one element. As a further evidence, you may even consider that Option comes with all the Scala collections goodness you love, like map() and flatMap().<br />
The second, more rigorous one deals with the concept of “for loop”: in fact, we imperative programmers are used to consider the “for” keyword as just a means to loop. Yet, in Scala, “for” can be much more: as it’s well explained <a href="http://docs.scala-lang.org/tutorials/FAQ/yield.html">here</a> and <a href="http://nerd.kelseyinnis.com/blog/2013/11/12/idiomatic-scala-the-for-comprehension/">here</a>, “for” has other uses, one being the so called “for comprehension” (or “for-yield”).<br />
You may be familiar with Python’s (or Ruby’s) list comprehension, the syntactic construct for creating a list based on existing lists. Scala’s “for” can be viewed as a generalization of list comprehension. Think of it as syntactic sugar hiding the composition of multiple operations.<br />
In this sense, for comprehension can be viewed as an equivalent to <a href="https://en.wikibooks.org/wiki/Haskell/do_notation">Haskell’s do notation</a>, allowing you to do simple looping, nested looping, list comprehension (thanks to our friend, yield) and, in general, composing multiple operations.</p>
<p>And you? What’s your opinion about this?</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
