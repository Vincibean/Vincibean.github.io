<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>My Hakyll Blog - Some Thoughts about Variance in Scala</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../contact.html">Contact</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Some Thoughts about Variance in Scala</h1>

            <div class="info">
    Posted on February  7, 2018
    
</div>

<p>Some time ago (so long ago!) I was asked by a fledgling (at the time) Scala developer to explain how covariance, contravariance and invariance work in Scala. Just like me, he came from Java, so getting all the technicalities of variance in Scala wasn’t straightforward for him (just like it wasn’t for me). The following is an adaptation of the answer I wrote to him.</p>
<h2 id="section-1">Section 1</h2>
<p><del>In Java, generics are invariant</del> (this is wrong; see <a href="#update-18th-february-2018">this update</a>). As a consequence, it is not possible to make an assignment like the following: <code>java ArrayList&lt;Animal&gt; dogs = new ArrayList&lt;Dog&gt;(); // Won't compile!</code></p>
<p>[Co | Contra | In] variance doesn’t mean that there are Upper or Lower bounds; more than anything else, it defines the relationships of the “wrappers” (here: <code>ArrayList</code>) according to the type hierarchy (here: Animal and Dog). In this case, since there is no such relationship, it is not possible: in the eyes of the compiler, <code>ArrayList&lt;Animal&gt;</code> and <code>ArrayList&lt;Dog&gt;</code> are like two totally disconnected classes.</p>
<h2 id="section-2">Section 2</h2>
<p>In Scala, the <code>List</code> class is covariant, as you can see here:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb1-1" title="1"><span class="kw">val</span> dogs: List[Animal] = List.<span class="fu">empty</span>[Dog]</a></code></pre></div>
<p>Here the assignment works, since List is covariant. The basic idea is that, if a collection can store animals, then it can store dogs.</p>
<h2 id="section-3">Section 3</h2>
<p>Let’s define the following hierarchy:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb2-1" title="1"><span class="kw">class</span> Living</a>
<a class="sourceLine" id="cb2-2" title="2"><span class="kw">class</span> Animal <span class="kw">extends</span> Living</a>
<a class="sourceLine" id="cb2-3" title="3"><span class="kw">class</span> Cat <span class="kw">extends</span> Animal</a></code></pre></div>
<p>and then the various “container classes” using the upper and lower bounds:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb3-1" title="1"><span class="kw">class</span> InvariantCage[T](<span class="kw">val</span> t: T)</a>
<a class="sourceLine" id="cb3-2" title="2"><span class="kw">class</span> UpperBoundCage[T &lt;: Animal](<span class="kw">val</span> t: T) <span class="co">// a cage where an upper bound is defined</span></a>
<a class="sourceLine" id="cb3-3" title="3"><span class="kw">class</span> LowerBoundCage[T &gt;: Animal](<span class="kw">val</span> t: T) <span class="co">// a cage where a lower bound is defined</span></a></code></pre></div>
<p>  For InvariantCage there is nothing else to mention.</p>
<p>For UpperBoundCage, this is what could happen:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb4-1" title="1"><span class="kw">val</span> u = <span class="kw">new</span> <span class="fu">UpperBoundCage</span>(<span class="kw">new</span> Animal)</a>
<a class="sourceLine" id="cb4-2" title="2"><span class="kw">val</span> u2 = <span class="kw">new</span> <span class="fu">UpperBoundCage</span>(<span class="kw">new</span> Living) <span class="co">// Will not compile</span></a>
<a class="sourceLine" id="cb4-3" title="3"><span class="kw">val</span> u3 = <span class="kw">new</span> <span class="fu">UpperBoundCage</span>(<span class="kw">new</span> Cat)</a></code></pre></div>
<p>This should not surprise: since <code>Living</code> is higher (with respect to the hierarchy) than the upper bound, the compiler reports an error.</p>
<p>For <code>LowerBoundCage</code>, the situation is a bit more complicated. Here’s what happens:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb5-1" title="1"><span class="kw">val</span> l = <span class="kw">new</span> <span class="fu">LowerBoundCage</span>(<span class="kw">new</span> Animal)</a>
<a class="sourceLine" id="cb5-2" title="2"><span class="kw">val</span> l2 = <span class="kw">new</span> <span class="fu">LowerBoundCage</span>(<span class="kw">new</span> Living)</a>
<a class="sourceLine" id="cb5-3" title="3"><span class="kw">val</span> l3 = <span class="kw">new</span> <span class="fu">LowerBoundCage</span>(<span class="kw">new</span> Cat)</a></code></pre></div>
<p>Apparently, it seems that everything compiles, even <code>l3</code>; in fact, if we look at the type of <code>l3</code>, we can see that something strange is happening:</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb6-1" title="1">l3: LowerBoundCage[Animal]</a></code></pre></div>
<p>The compiler, to avoid errors, transforms (‘upcasts’) the <code>Cat</code> into an <code>Animal</code>. That’s why it seems that everything is working fine. To return to the situation we want, we can ‘force’ the compiler to use the type we actually want, like this:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb7-1" title="1"><span class="kw">new</span> LowerBoundCage[Cat](<span class="kw">new</span> Cat) <span class="co">// Will not compile!</span></a></code></pre></div>
<p>Now the compiler knows what’s the type we want to use, and reports an error. Obviously, we can force the correct type also in the other cases (those that compile): we will never have this error.</p>
<h2 id="section-4">Section 4</h2>
<p>Regarding the added value that upper and lower bounds can give us, I have found two nice articles (<a href="https://www.ibm.com/developerworks/library/j-jtp07018/">here</a> and <a href="http://www.softwaregeek.net/2013/02/get-and-put-principle-in-java-generics.html">here</a>) where it is explained when it might make sense to use them… at the same time! The underlying principle is called ‘<code>get-put principle</code>’, and it says:</p>
<pre><code>Use an extends wildcard when you only get values ​​in a structure, and do not use a wildcard when you both get and put.</code></pre>
<p>The example that is provided (and that I tried to rewrite in Scala) is the following:</p>
<p>we try to write a method to pass data from one collection to another, trying to be as flexible as possible.</p>
<p>A first attempt could be the following (to avoid the problem of the covariance of List, we use ListBuffer, which is crappy, but is also invariant):</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb9-1" title="1"><span class="kw">def</span> transfer1[T](from: ListBuffer[T], to: ListBuffer[T]): ListBuffer[T] = {</a>
<a class="sourceLine" id="cb9-2" title="2">  <span class="kw">for</span> (f &lt;- from)</a>
<a class="sourceLine" id="cb9-3" title="3">    to += f</a>
<a class="sourceLine" id="cb9-4" title="4">  to</a>
<a class="sourceLine" id="cb9-5" title="5">}</a></code></pre></div>
<p><strong>(N.B.: ListBuffer is part of Scala’s mutable collections, so returning the filled ListBuffer is useless, it’s for educational purposes only)</strong></p>
<p>Now let’s try our function: transfer the contents of a <code>Cat</code> <code>ListBuffer</code> to an <code>Animal</code> <code>ListBuffer</code>.</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb10-1" title="1"><span class="fu">transfer1</span>(ListBuffer[Cat](<span class="kw">new</span> <span class="fu">Cat</span>(), <span class="kw">new</span> <span class="fu">Cat</span>(), <span class="kw">new</span> <span class="fu">Cat</span>()), ListBuffer.<span class="fu">empty</span>[Animal])  <span class="co">// Won't compile</span></a></code></pre></div>
<p>It won’t compile, for the usual problem about invariance.</p>
<p>Let’s try to modify the function by adding a Lower Bound (we are therefore in the “put” side of the <code>get-put principle</code>):</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb11-1" title="1"><span class="kw">def</span> transfer2[T](from: ListBuffer[T], to: ListBuffer[_ &gt;: T]): ListBuffer[_ &gt;: T] = {</a>
<a class="sourceLine" id="cb11-2" title="2">  <span class="kw">for</span> (f &lt;- from)</a>
<a class="sourceLine" id="cb11-3" title="3">    to += f</a>
<a class="sourceLine" id="cb11-4" title="4">  to</a>
<a class="sourceLine" id="cb11-5" title="5">}</a></code></pre></div>
<p>Now the example compiles! But let’s try to pass him a <code>HelloKitty</code> <code>ListBuffer</code> (a subtype of <code>Cat</code>):</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb12-1" title="1"><span class="fu">transfer2</span>(ListBuffer(<span class="kw">new</span> <span class="fu">HelloKitty</span>(), <span class="kw">new</span> <span class="fu">HelloKitty</span>(), <span class="kw">new</span> <span class="fu">HelloKitty</span>()), ListBuffer.<span class="fu">empty</span>[Animal])   <span class="co">// Won't compile!</span></a></code></pre></div>
<p>It doesn’t compile again. Let’s try to modify the function by adding an Upper Bound (here we are in the “get” side of the <code>get-put principle</code>):</p>
<div class="sourceCode" id="cb13"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb13-1" title="1"><span class="kw">def</span> transfer3[T](from: ListBuffer[_ &lt;: T], to: ListBuffer[_ &gt;: T]): ListBuffer[_ &gt;: T] = {</a>
<a class="sourceLine" id="cb13-2" title="2">  <span class="kw">for</span> (f &lt;- from)</a>
<a class="sourceLine" id="cb13-3" title="3">    to += f</a>
<a class="sourceLine" id="cb13-4" title="4">  to</a>
<a class="sourceLine" id="cb13-5" title="5">}</a></code></pre></div>
<p>Now the example compiles!</p>
<h2 id="section-5">Section 5</h2>
<p>The example above has a pattern that seems familiar: on the one hand, a “producer” (from) that is better to make covariant, on the other a “consumer” (to) that is better to make contravariant. It looks like… the <code>trait</code> <code>Function1</code>! As you know, a lambda in Scala is syntactic sugar: at compile time, they are transformed into instances that implement the <code>FunctionN</code> type (where N is the number of arguments of the function); the <code>trait</code> <code>Function1</code> in particular, as you can see here, has a signature that, in general, looks like what we had before:</p>
<div class="sourceCode" id="cb14"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb14-1" title="1"><span class="kw">trait</span> Function1 [-T1, +R]</a></code></pre></div>
<p>We can try to implement our own function now:</p>
<div class="sourceCode" id="cb15"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb15-1" title="1"><span class="kw">val</span> myF = <span class="kw">new</span> Function1[Cat, Animal] {</a>
<a class="sourceLine" id="cb15-2" title="2">  <span class="kw">override</span> <span class="kw">def</span> <span class="fu">apply</span>(c: Cat): Animal = <span class="kw">new</span> Animal <span class="co">// Simple substitution</span></a>
<a class="sourceLine" id="cb15-3" title="3">}</a></code></pre></div>
<p>This function can be used in this way:</p>
<div class="sourceCode" id="cb16"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb16-1" title="1"><span class="kw">val</span> animals: List[Animal] = List(<span class="kw">new</span> Cat).<span class="fu">map</span>(myF)</a></code></pre></div>
<p>But we can also use it on different types:</p>
<pre><code>val livings: List [Living] = List(new HelloKitty).map(myF)</code></pre>
<p>Here we use as an argument of the function <code>HelloKitty</code> type (a subclass of <code>Cat</code>) and return instances of <code>Living</code> type (superclass of <code>Animal</code>). So we have a good example of variance: our friendly neighborhood lambda!</p>
<h1 id="update-18th-february-2018">Update (18th February 2018)</h1>
<p>This blog post ended up gaining a lot more interest than I expected, especially considering that it started as a simple email to explain a Scala concept in simple terms.</p>
<p>In particular, a reader highlighted an error: this blog post starts by stating that &gt; In Java, generics are invariant</p>
<p>This is incorrect: in Java it is possible to achieve variance… through type-bounds!</p>
<p>But let’s start with definitions</p>
<h2 id="use-site-variance-declaration-site-variance">Use-Site Variance &amp; Declaration-Site Variance</h2>
<p>In this blog post, I’ve been using the term ‘variance’ quite roughly. It turns out that variance can be classified into two categories: - Use-Site Variance - Declaration-Site Variance</p>
<p>Let’s see them in detail.</p>
<p>With <strong>use-site variance</strong>, every time you use a generic class/interface you furthermore specify whether you want to access it invariantly, covariantly or contravariantly.</p>
<p>Conversely, with <strong>declaration-site variance</strong>, every time you declare a generic class/interface you furthermore specify whether it should be used invariantly, covariantly or contravariantly.</p>
<p>As stated before, in Java it is possible to achieve variance: in particular, it is possible to achieve use-site variance, and as previously stated the way to do this is through bound types.</p>
<p>Let’s turn our <code>InvariantCage</code> into a Java class:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb18-1" title="1"><span class="kw">public</span> <span class="kw">class</span> InvariantCage&lt;T&gt; {</a>
<a class="sourceLine" id="cb18-2" title="2">    </a>
<a class="sourceLine" id="cb18-3" title="3">    <span class="kw">private</span> T t;</a>
<a class="sourceLine" id="cb18-4" title="4">    </a>
<a class="sourceLine" id="cb18-5" title="5">    <span class="kw">public</span> <span class="fu">InvariantCage</span>(T t) {</a>
<a class="sourceLine" id="cb18-6" title="6">        <span class="kw">this</span>.<span class="fu">t</span> = t;</a>
<a class="sourceLine" id="cb18-7" title="7">    }</a>
<a class="sourceLine" id="cb18-8" title="8">    </a>
<a class="sourceLine" id="cb18-9" title="9">    <span class="kw">public</span> T <span class="fu">getT</span>() {</a>
<a class="sourceLine" id="cb18-10" title="10">        <span class="kw">return</span> t;</a>
<a class="sourceLine" id="cb18-11" title="11">    }</a>
<a class="sourceLine" id="cb18-12" title="12"></a>
<a class="sourceLine" id="cb18-13" title="13">}</a></code></pre></div>
<p>We can take advantage of use-site variance in Java like this:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb19-1" title="1">InvariantCage&lt;? <span class="kw">extends</span> Animal&gt; cage = <span class="kw">new</span> InvariantCage&lt;&gt;(<span class="kw">new</span> <span class="fu">Cat</span>());</a></code></pre></div>
<p>Yes: we are using an InvariantCage (i.e. a cage that was defined as invariant) in a covariant way by taking advantage of use-site variance.</p>
<h2 id="use-site-variance-is-this-enough-to-have-variance">Use-Site Variance? Is This Enough To Have Variance?</h2>
<p>There’s a way to prove that variance is actually taking place: the <code>Liskov Substitution Principle</code>. <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">It states that</a> if S is a subtype of T, then objects of type T may be replaced with objects of type S (i.e. an object of type T may be substituted with any object of a subtype S) without altering any of the desirable properties of T (correctness, task performed, etc.)</p>
<p>We now have a tool to formally check if everything we said so far holds true.</p>
<p>Let’s start with Scala. Scala allows declaration-site variance, which means that, in order to define a covariant cage, we can use the following notation:</p>
<div class="sourceCode" id="cb20"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb20-1" title="1"><span class="kw">class</span> CovariantCage[+T](<span class="kw">val</span> t: T)</a></code></pre></div>
<p>OK, now we need to see if the Liskov Substitution Principle (LSP) holds true, that is, we need to see if a <code>CovariantCage[Cat]</code> can be substituted to a <code>CovariantCage[Animale]</code>. The simplest form of “substitution” is the assignment.</p>
<div class="sourceCode" id="cb21"><pre class="sourceCode scala"><code class="sourceCode scala"><a class="sourceLine" id="cb21-1" title="1"><span class="kw">val</span> cd: CovariantCage[Animal] = <span class="kw">new</span> CovariantCage[Cat](<span class="kw">new</span> <span class="fu">Cat</span>())</a></code></pre></div>
<p>That is, we are substituting (assigning) an object of type <code>CovariantCage[Cat]</code> to an object (reference) of type <code>CovariantCage[Cat]</code> without altering any of the ‘desirable properties’ (in fact, we are providing a <code>Cat</code>, which is a specialization over <code>Animal</code>).</p>
<p>Let’s see if the same holds true for the Java case. Here, we’ll have to resort to use-site variance:</p>
<div class="sourceCode" id="cb22"><pre class="sourceCode java"><code class="sourceCode java"><a class="sourceLine" id="cb22-1" title="1">InvariantCage&lt;? <span class="kw">extends</span> Animal&gt; cage = <span class="kw">new</span> InvariantCage&lt;Cat&gt;(<span class="kw">new</span> <span class="fu">Cat</span>());</a></code></pre></div>
<p>Again, the LSP tells us that what we wrote holds true.</p>
<h1 id="is-that-all">Is that all?</h1>
<p>Well, no. There are still a couple of things that aren’t quite clear to me, and this lurks into this blog post. I’ll probably add another update once things are a bit clearer.</p>
<p>Do you have any question so far? If this is the case, don’t hesitate to <a href="mailto:andrebessi00@gmail.com">let me know</a></p>
<h1 id="resources">Resources</h1>
<ul>
<li><span class="citation" data-cites="sinisalouc/variance-in-java-and-scala-63af925d21dc">[https://medium.com/@sinisalouc/variance-in-java-and-scala-63af925d21dc]</span>(https://medium.com/<span class="citation" data-cites="sinisalouc/variance-in-java-and-scala-63af925d21dc">@sinisalouc/variance-in-java-and-scala-63af925d21dc</span>)</li>
<li><a href="https://dzone.com/articles/covariance-and-contravariance" class="uri">https://dzone.com/articles/covariance-and-contravariance</a></li>
<li><a href="http://shop.oreilly.com/product/9780596527754.do">Java Generics and Collections by Maurice Naftalin and Philip Wadler, ch.2</a></li>
<li><a href="https://www.amazon.com/Programming-Scala-Comprehensive-Step-Step/dp/0981531644">Programming in Scala, Second Edition, by Martin Odersky, Lex Spoon and Bill Venners, ch. 19</a></li>
<li><a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">The Liskov Substitiution Principle according to Wikipedia</a></li>
</ul>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
